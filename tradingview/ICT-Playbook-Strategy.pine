// This Pine Script™ is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/
// © MarketPlaymaker — ICT Playbook Strategy v1.0
// Based on the full MarketPlaymaker Playbook: MSS, FVG, OB, OTE, Killzones, Liquidity Sweeps

//@version=5
strategy("ICT Playbook Strategy", overlay=true, margin_long=100, margin_short=100,
     default_qty_type=strategy.percent_of_equity, default_qty_value=2,
     initial_capital=100000, commission_type=strategy.commission.percent,
     commission_value=0.01, slippage=1, calc_on_every_tick=false,
     max_bars_back=500, pyramiding=0)

// ══════════════════════════════════════════════════════════════════════════════
// ─── INPUTS ─────────────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// ── General ──
grp_gen = "═══ General Settings ═══"
i_direction     = input.string("Both", "Trade Direction", options=["Long Only", "Short Only", "Both"], group=grp_gen)
i_riskPct       = input.float(1.0, "Risk Per Trade %", minval=0.1, maxval=5.0, step=0.1, group=grp_gen)
i_maxDailyTrades = input.int(2, "Max Trades Per Day", minval=1, maxval=10, group=grp_gen)

// ── Structure Detection ──
grp_struct = "═══ Structure Detection ═══"
i_swingLen      = input.int(5, "Swing Detection Length", minval=2, maxval=20, group=grp_struct, tooltip="Lookback for swing high/low pivots")
i_mssDisplace   = input.float(0.5, "MSS Min Displacement (× ATR)", minval=0.1, maxval=3.0, step=0.1, group=grp_struct, tooltip="Minimum candle body size relative to ATR to qualify as displacement")
i_requireDisp   = input.bool(true, "Require Displacement for MSS", group=grp_struct)

// ── FVG Settings ──
grp_fvg = "═══ Fair Value Gap ═══"
i_fvgEnabled    = input.bool(true, "Enable FVG Detection", group=grp_fvg)
i_fvgMinSize    = input.float(0.2, "Min FVG Size (× ATR)", minval=0.05, maxval=2.0, step=0.05, group=grp_fvg)
i_fvgEntry      = input.string("CE (50%)", "FVG Entry Method", options=["Complete Fill", "CE (50%)", "FVG Edge"], group=grp_fvg, tooltip="Complete Fill = safest (75% fill rate, 2-4R)\nCE = balanced (90% fill, 3-6R)\nFVG Edge = aggressive (95% fill, 5-10R)")
i_fvgMaxAge     = input.int(50, "Max FVG Age (bars)", minval=5, maxval=200, group=grp_fvg)
i_showFVG       = input.bool(true, "Show FVG Zones", group=grp_fvg)

// ── Order Block Settings ──
grp_ob = "═══ Order Blocks ═══"
i_obEnabled     = input.bool(true, "Enable Order Block Detection", group=grp_ob)
i_obMaxTouches  = input.int(2, "Max OB Touches Before Invalid", minval=1, maxval=5, group=grp_ob, tooltip="OBs tapped 2+ times are exhausted")
i_showOB        = input.bool(true, "Show Order Block Zones", group=grp_ob)

// ── OTE Settings ──
grp_ote = "═══ Optimal Trade Entry ═══"
i_oteEnabled    = input.bool(true, "Enable OTE Entries", group=grp_ote)
i_oteLow        = input.float(0.62, "OTE Zone Start (Fib)", minval=0.5, maxval=0.8, step=0.01, group=grp_ote)
i_oteHigh       = input.float(0.79, "OTE Zone End (Fib)", minval=0.6, maxval=0.95, step=0.01, group=grp_ote)
i_oteSweet      = input.float(0.705, "OTE Sweet Spot (Fib)", minval=0.5, maxval=0.9, step=0.005, group=grp_ote)

// ── Stop Loss ──
grp_sl = "═══ Stop Loss ═══"
i_slType        = input.string("FVG Invalidation", "Stop Loss Type", options=["Candle Body", "FVG Invalidation", "OB Invalidation", "Swing Point"], group=grp_sl, tooltip="Candle Body = tightest (8-15R)\nFVG = tight (4-8R)\nOB = medium (3-5R)\nSwing = safest (1.5-3R)")
i_slBuffer      = input.float(0.5, "SL Buffer (× ATR)", minval=0.0, maxval=2.0, step=0.1, group=grp_sl, tooltip="Extra buffer beyond the SL level")

// ── Take Profit ──
grp_tp = "═══ Take Profit ═══"
i_tp1RR         = input.float(2.0, "TP1 R:R Ratio", minval=0.5, maxval=10.0, step=0.5, group=grp_tp)
i_tp1Pct        = input.float(25, "TP1 Close %", minval=10, maxval=100, step=5, group=grp_tp)
i_tp2RR         = input.float(4.0, "TP2 R:R Ratio", minval=1.0, maxval=15.0, step=0.5, group=grp_tp)
i_tp2Pct        = input.float(50, "TP2 Close %", minval=0, maxval=100, step=5, group=grp_tp)
i_tpTrail       = input.bool(true, "Trail Remaining Position", group=grp_tp)
i_trailATR      = input.float(2.0, "Trailing Stop (× ATR)", minval=0.5, maxval=5.0, step=0.5, group=grp_tp)

// ── Session / Killzone Filters ──
grp_kz = "═══ Killzones (EST / UTC-5) ═══"
i_kzFilter      = input.bool(true, "Only Trade During Killzones", group=grp_kz)
i_kzLondon      = input.bool(true, "London KZ (02:00–05:00)", group=grp_kz)
i_kzNYAM        = input.bool(true, "NY AM KZ (08:30–11:00)", group=grp_kz)
i_kzNYPM        = input.bool(false, "NY PM KZ (13:30–16:00)", group=grp_kz)
i_kzSilverAM    = input.bool(true, "AM Silver Bullet (10:00–11:00)", group=grp_kz)
i_kzSilverPM    = input.bool(false, "PM Silver Bullet (14:00–15:00)", group=grp_kz)
i_avoidMonday   = input.bool(true, "Avoid Monday", group=grp_kz)
i_avoidFriday   = input.bool(false, "Avoid Friday", group=grp_kz)
i_avoidLunch    = input.bool(true, "Avoid NY Lunch (12:00–13:30)", group=grp_kz)
i_closeLunch    = input.bool(true, "Close Before Lunch (12:00)", group=grp_kz, tooltip="Close or heavy partial by 12:00 — never hold through NY lunch")
i_tzOffset      = input.int(-5, "UTC Offset (EST = -5, EDT = -4)", minval=-12, maxval=12, group=grp_kz)

// ── Liquidity Sweep ──
grp_liq = "═══ Liquidity Sweep ═══"
i_liqEnabled    = input.bool(true, "Enable Liquidity Sweep Entries", group=grp_liq)
i_liqLookback   = input.int(20, "PDH/PDL Lookback (bars)", minval=5, maxval=100, group=grp_liq)
i_showLiq       = input.bool(true, "Show Liquidity Levels", group=grp_liq)

// ── Visuals ──
grp_vis = "═══ Visual Settings ═══"
i_showDash      = input.bool(true, "Show Dashboard", group=grp_vis)
i_showStructure = input.bool(true, "Show Structure Labels", group=grp_vis)
i_bullColor     = input.color(#4ade80, "Bullish Color", group=grp_vis)
i_bearColor     = input.color(#f87171, "Bearish Color", group=grp_vis)
i_fvgBullColor  = input.color(color.new(#4ade80, 85), "FVG Bullish Fill", group=grp_vis)
i_fvgBearColor  = input.color(color.new(#f87171, 85), "FVG Bearish Fill", group=grp_vis)
i_obBullColor   = input.color(color.new(#22d3ee, 85), "OB Bullish Fill", group=grp_vis)
i_obBearColor   = input.color(color.new(#f59e0b, 85), "OB Bearish Fill", group=grp_vis)

// ══════════════════════════════════════════════════════════════════════════════
// ─── CORE CALCULATIONS ──────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

atr14 = ta.atr(14)
atr50 = ta.atr(50)

// ── Session Time Functions ──
f_inSession(_utcOff, _startH, _startM, _endH, _endM) =>
    // Convert current bar time to session timezone
    t = time
    h = hour(t, "America/New_York")
    m = minute(t, "America/New_York")
    totalMin = h * 60 + m
    startMin = _startH * 60 + _startM
    endMin   = _endH * 60 + _endM
    totalMin >= startMin and totalMin < endMin

isLondonKZ  = f_inSession(i_tzOffset, 2, 0, 5, 0)
isNYAMKZ    = f_inSession(i_tzOffset, 8, 30, 11, 0)
isNYPMKZ    = f_inSession(i_tzOffset, 13, 30, 16, 0)
isSilverAM  = f_inSession(i_tzOffset, 10, 0, 11, 0)
isSilverPM  = f_inSession(i_tzOffset, 14, 0, 15, 0)
isNYLunch   = f_inSession(i_tzOffset, 12, 0, 13, 30)

isKillzone = (i_kzLondon and isLondonKZ) or (i_kzNYAM and isNYAMKZ) or (i_kzNYPM and isNYPMKZ) or (i_kzSilverAM and isSilverAM) or (i_kzSilverPM and isSilverPM)
kzAllowed  = i_kzFilter ? isKillzone : true

// ── Day of Week ──
dow = dayofweek(time, "America/New_York")
isMonday  = dow == dayofweek.monday
isFriday  = dow == dayofweek.friday
dayAllowed = (not i_avoidMonday or not isMonday) and (not i_avoidFriday or not isFriday)
lunchBlock = i_avoidLunch and isNYLunch

sessionOK = kzAllowed and dayAllowed and not lunchBlock

// ── Daily Trade Counter ──
var int dailyTrades = 0
newDay = ta.change(time("D")) != 0
if newDay
    dailyTrades := 0
tradeAllowed = dailyTrades < i_maxDailyTrades

// ══════════════════════════════════════════════════════════════════════════════
// ─── MARKET STRUCTURE ───────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// Swing highs and lows
swingHigh = ta.pivothigh(high, i_swingLen, i_swingLen)
swingLow  = ta.pivotlow(low, i_swingLen, i_swingLen)

var float lastSwingHigh  = na
var float lastSwingLow   = na
var float prevSwingHigh  = na
var float prevSwingLow   = na
var int   lastSwingHighBar = na
var int   lastSwingLowBar  = na

if not na(swingHigh)
    prevSwingHigh   := lastSwingHigh
    lastSwingHigh   := swingHigh
    lastSwingHighBar := bar_index - i_swingLen

if not na(swingLow)
    prevSwingLow   := lastSwingLow
    lastSwingLow   := swingLow
    lastSwingLowBar := bar_index - i_swingLen

// ── Structure Shift Detection ──
// Displacement check: candle body must be significant
bodySize    = math.abs(close - open)
isDisplacement = bodySize > atr14 * i_mssDisplace

// Bullish MSS: price breaks above last swing high with displacement
// After sweeping sell-side liquidity (took out a low first)
var int   structureBias = 0  // 1 = bullish, -1 = bearish, 0 = neutral
var float mssLevel      = na
var int   mssBar        = na

bullishBOS = close > lastSwingHigh and not na(lastSwingHigh)
bearishBOS = close < lastSwingLow and not na(lastSwingLow)

bullishMSS = bullishBOS and (not i_requireDisp or isDisplacement) and structureBias <= 0
bearishMSS = bearishBOS and (not i_requireDisp or isDisplacement) and structureBias >= 0

if bullishMSS
    structureBias := 1
    mssLevel := lastSwingHigh
    mssBar := bar_index

if bearishMSS
    structureBias := -1
    mssLevel := lastSwingLow
    mssBar := bar_index

// Structure labels
if i_showStructure and bullishMSS
    label.new(bar_index, low, "MSS ▲", style=label.style_label_up, color=i_bullColor, textcolor=color.white, size=size.tiny)
if i_showStructure and bearishMSS
    label.new(bar_index, high, "MSS ▼", style=label.style_label_down, color=i_bearColor, textcolor=color.white, size=size.tiny)

// BOS labels (continuation)
bullishBOSCont = bullishBOS and structureBias == 1 and not bullishMSS
bearishBOSCont = bearishBOS and structureBias == -1 and not bearishMSS
if i_showStructure and bullishBOSCont
    label.new(bar_index, low, "BOS", style=label.style_label_up, color=color.new(i_bullColor, 60), textcolor=color.white, size=size.tiny)
if i_showStructure and bearishBOSCont
    label.new(bar_index, high, "BOS", style=label.style_label_down, color=color.new(i_bearColor, 60), textcolor=color.white, size=size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// ─── FAIR VALUE GAPS ────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// FVG: 3-candle pattern — gap between candle 1 & candle 3
// Bullish: low[0] > high[2] (gap between C1 high and C3 low)
// Bearish: high[0] < low[2] (gap between C1 low and C3 high)

var float[] fvgTopArr    = array.new_float(0)
var float[] fvgBotArr    = array.new_float(0)
var int[]   fvgBarArr    = array.new_int(0)
var int[]   fvgDirArr    = array.new_int(0)    // 1 = bull, -1 = bear
var bool[]  fvgActiveArr = array.new_bool(0)   // track if still valid

bullFVG = i_fvgEnabled and low > high[2] and (low - high[2]) > atr14 * i_fvgMinSize
bearFVG = i_fvgEnabled and high < low[2] and (low[2] - high) > atr14 * i_fvgMinSize

if bullFVG
    array.push(fvgTopArr, low)
    array.push(fvgBotArr, high[2])
    array.push(fvgBarArr, bar_index)
    array.push(fvgDirArr, 1)
    array.push(fvgActiveArr, true)

if bearFVG
    array.push(fvgTopArr, low[2])
    array.push(fvgBotArr, high)
    array.push(fvgBarArr, bar_index)
    array.push(fvgDirArr, -1)
    array.push(fvgActiveArr, true)

// Manage FVG lifecycle: expire old FVGs, mark filled ones
if array.size(fvgTopArr) > 0
    for i = array.size(fvgTopArr) - 1 to 0
        age = bar_index - array.get(fvgBarArr, i)
        if age > i_fvgMaxAge
            array.remove(fvgTopArr, i)
            array.remove(fvgBotArr, i)
            array.remove(fvgBarArr, i)
            array.remove(fvgDirArr, i)
            array.remove(fvgActiveArr, i)
            continue
        
        fTop = array.get(fvgTopArr, i)
        fBot = array.get(fvgBotArr, i)
        fDir = array.get(fvgDirArr, i)
        
        // Check if FVG has been fully filled
        if fDir == 1 and low <= fBot
            array.set(fvgActiveArr, i, false)
        if fDir == -1 and high >= fTop
            array.set(fvgActiveArr, i, false)

// Draw FVG boxes
if i_showFVG and array.size(fvgTopArr) > 0
    for i = 0 to math.min(array.size(fvgTopArr) - 1, 19)  // limit to 20
        if array.get(fvgActiveArr, i)
            fDir = array.get(fvgDirArr, i)
            fTop = array.get(fvgTopArr, i)
            fBot = array.get(fvgBotArr, i)
            fBar = array.get(fvgBarArr, i)
            clr = fDir == 1 ? i_fvgBullColor : i_fvgBearColor
            box.new(fBar, fTop, bar_index, fBot, bgcolor=clr, border_color=color.new(fDir == 1 ? i_bullColor : i_bearColor, 60), border_width=1, xloc=xloc.bar_index)

// Find nearest active FVG for entry
f_nearestFVG(_dir) =>
    float bestTop = na
    float bestBot = na
    float bestDist = 1e10
    if array.size(fvgTopArr) > 0
        for i = 0 to array.size(fvgTopArr) - 1
            if array.get(fvgActiveArr, i) and array.get(fvgDirArr, i) == _dir
                fTop = array.get(fvgTopArr, i)
                fBot = array.get(fvgBotArr, i)
                ce   = (fTop + fBot) / 2
                dist = math.abs(close - ce)
                if dist < bestDist
                    bestDist := dist
                    bestTop  := fTop
                    bestBot  := fBot
    [bestTop, bestBot]

[nearBullFVGTop, nearBullFVGBot] = f_nearestFVG(1)
[nearBearFVGTop, nearBearFVGBot] = f_nearestFVG(-1)

// FVG entry levels
f_fvgEntryLevel(_top, _bot, _dir) =>
    float lvl = na
    if not na(_top) and not na(_bot)
        if i_fvgEntry == "Complete Fill"
            lvl := _dir == 1 ? _bot : _top
        else if i_fvgEntry == "CE (50%)"
            lvl := (_top + _bot) / 2
        else // FVG Edge
            lvl := _dir == 1 ? _top : _bot
    lvl

bullFVGEntry = f_fvgEntryLevel(nearBullFVGTop, nearBullFVGBot, 1)
bearFVGEntry = f_fvgEntryLevel(nearBearFVGTop, nearBearFVGBot, -1)

// ══════════════════════════════════════════════════════════════════════════════
// ─── ORDER BLOCKS ───────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// Bullish OB: last down-close candle before bullish displacement
// Bearish OB: last up-close candle before bearish displacement

var float[] obTopArr     = array.new_float(0)
var float[] obBotArr     = array.new_float(0)
var int[]   obBarArr     = array.new_int(0)
var int[]   obDirArr     = array.new_int(0)
var int[]   obTouchArr   = array.new_int(0)
var bool[]  obActiveArr  = array.new_bool(0)

// Detect OBs: displacement candle preceded by opposing candle
bullDisplacement = close > open and bodySize > atr14 * i_mssDisplace and close[1] < open[1]  // bullish displacement after bearish candle
bearDisplacement = close < open and bodySize > atr14 * i_mssDisplace and close[1] > open[1]  // bearish displacement after bullish candle

if i_obEnabled and bullDisplacement
    // The OB is the bearish candle before displacement
    array.push(obTopArr, math.max(open[1], close[1]))  // OB body high
    array.push(obBotArr, math.min(open[1], close[1]))  // OB body low
    array.push(obBarArr, bar_index - 1)
    array.push(obDirArr, 1)
    array.push(obTouchArr, 0)
    array.push(obActiveArr, true)

if i_obEnabled and bearDisplacement
    array.push(obTopArr, math.max(open[1], close[1]))
    array.push(obBotArr, math.min(open[1], close[1]))
    array.push(obBarArr, bar_index - 1)
    array.push(obDirArr, -1)
    array.push(obTouchArr, 0)
    array.push(obActiveArr, true)

// Manage OB lifecycle
if array.size(obTopArr) > 0
    for i = array.size(obTopArr) - 1 to 0
        age = bar_index - array.get(obBarArr, i)
        if age > 200  // OBs older than 200 bars removed
            array.remove(obTopArr, i)
            array.remove(obBotArr, i)
            array.remove(obBarArr, i)
            array.remove(obDirArr, i)
            array.remove(obTouchArr, i)
            array.remove(obActiveArr, i)
            continue
        
        oTop = array.get(obTopArr, i)
        oBot = array.get(obBotArr, i)
        oDir = array.get(obDirArr, i)
        touches = array.get(obTouchArr, i)
        
        // Check if price entered OB zone (touch)
        inZone = low <= oTop and high >= oBot
        if inZone and array.get(obActiveArr, i)
            array.set(obTouchArr, i, touches + 1)
        
        // Invalidate if too many touches or price displaced through
        if touches >= i_obMaxTouches
            array.set(obActiveArr, i, false)
        // Bullish OB invalidated if price closes below it
        if oDir == 1 and close < oBot
            array.set(obActiveArr, i, false)
        // Bearish OB invalidated if price closes above it
        if oDir == -1 and close > oTop
            array.set(obActiveArr, i, false)

// Draw OB boxes
if i_showOB and array.size(obTopArr) > 0
    for i = 0 to math.min(array.size(obTopArr) - 1, 14)
        if array.get(obActiveArr, i)
            oDir = array.get(obDirArr, i)
            oTop = array.get(obTopArr, i)
            oBot = array.get(obBotArr, i)
            oBar = array.get(obBarArr, i)
            clr = oDir == 1 ? i_obBullColor : i_obBearColor
            box.new(oBar, oTop, bar_index, oBot, bgcolor=clr, border_color=color.new(oDir == 1 ? #22d3ee : #f59e0b, 60), border_width=1, border_style=line.style_dashed, xloc=xloc.bar_index)

// Find nearest active OB
f_nearestOB(_dir) =>
    float bestTop = na
    float bestBot = na
    float bestDist = 1e10
    if array.size(obTopArr) > 0
        for i = 0 to array.size(obTopArr) - 1
            if array.get(obActiveArr, i) and array.get(obDirArr, i) == _dir
                oTop = array.get(obTopArr, i)
                oBot = array.get(obBotArr, i)
                mid  = (oTop + oBot) / 2
                dist = math.abs(close - mid)
                if dist < bestDist
                    bestDist := dist
                    bestTop  := oTop
                    bestBot  := oBot
    [bestTop, bestBot]

[nearBullOBTop, nearBullOBBot] = f_nearestOB(1)
[nearBearOBTop, nearBearOBBot] = f_nearestOB(-1)

// OB entry at mean threshold (50%)
bullOBEntry = not na(nearBullOBTop) ? (nearBullOBTop + nearBullOBBot) / 2 : na
bearOBEntry = not na(nearBearOBTop) ? (nearBearOBTop + nearBearOBBot) / 2 : na

// ══════════════════════════════════════════════════════════════════════════════
// ─── OTE (OPTIMAL TRADE ENTRY) ──────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// After an MSS, calculate the fib retracement of the displacement leg
// OTE zone = 62%–79% retracement

var float oteSwingHigh  = na
var float oteSwingLow   = na
var bool  oteActive     = false
var int   oteDirection  = 0

if bullishMSS
    oteSwingLow  := lastSwingLow
    oteSwingHigh := high
    oteActive    := true
    oteDirection := 1

if bearishMSS
    oteSwingHigh := lastSwingHigh
    oteSwingLow  := low
    oteActive    := true
    oteDirection := -1

// OTE levels
oteRange    = oteSwingHigh - oteSwingLow
oteLevelLow  = oteDirection == 1 ? oteSwingHigh - oteRange * i_oteHigh : oteSwingLow + oteRange * i_oteLow
oteLevelHigh = oteDirection == 1 ? oteSwingHigh - oteRange * i_oteLow : oteSwingLow + oteRange * i_oteHigh
oteSweet     = oteDirection == 1 ? oteSwingHigh - oteRange * i_oteSweet : oteSwingLow + oteRange * i_oteSweet
inOTEZone    = oteActive and low <= math.max(oteLevelLow, oteLevelHigh) and high >= math.min(oteLevelLow, oteLevelHigh)

// Deactivate OTE after entry or if price breaks the swing
if oteActive and oteDirection == 1 and close < oteSwingLow
    oteActive := false
if oteActive and oteDirection == -1 and close > oteSwingHigh
    oteActive := false

// ══════════════════════════════════════════════════════════════════════════════
// ─── LIQUIDITY LEVELS ───────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// PDH/PDL (Previous Day High/Low)
pdh = request.security(syminfo.tickerid, "D", high[1], lookahead=barmerge.lookahead_on)
pdl = request.security(syminfo.tickerid, "D", low[1], lookahead=barmerge.lookahead_on)

// PWH/PWL (Previous Week High/Low)
pwh = request.security(syminfo.tickerid, "W", high[1], lookahead=barmerge.lookahead_on)
pwl = request.security(syminfo.tickerid, "W", low[1], lookahead=barmerge.lookahead_on)

// EQH/EQL detection (equal highs/lows — liquidity pools)
eqhThreshold = atr14 * 0.1
eqlThreshold = atr14 * 0.1

hasEQH = not na(lastSwingHigh) and not na(prevSwingHigh) and math.abs(lastSwingHigh - prevSwingHigh) < eqhThreshold
hasEQL = not na(lastSwingLow) and not na(prevSwingLow) and math.abs(lastSwingLow - prevSwingLow) < eqlThreshold

// Liquidity sweep detection: price wicks through then closes back
bullLiqSweep = i_liqEnabled and (low < pdl or low < lastSwingLow) and close > open and close > pdl
bearLiqSweep = i_liqEnabled and (high > pdh or high > lastSwingHigh) and close < open and close < pdh

// Draw liquidity levels
if i_showLiq
    if not na(pdh) and barstate.islast
        line.new(bar_index - 20, pdh, bar_index, pdh, color=color.new(#f59e0b, 50), style=line.style_dotted, width=1)
        label.new(bar_index, pdh, "PDH", style=label.style_none, textcolor=color.new(#f59e0b, 50), size=size.tiny)
    if not na(pdl) and barstate.islast
        line.new(bar_index - 20, pdl, bar_index, pdl, color=color.new(#f59e0b, 50), style=line.style_dotted, width=1)
        label.new(bar_index, pdl, "PDL", style=label.style_none, textcolor=color.new(#f59e0b, 50), size=size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// ─── ENTRY SIGNALS ──────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// Direction filter
canLong  = i_direction != "Short Only"
canShort = i_direction != "Long Only"

// ── Composite Long Signal ──
// MSS bullish + price in FVG/OB/OTE zone + killzone confirmed
fvgLongTrigger = i_fvgEnabled and not na(bullFVGEntry) and low <= nearBullFVGTop and close > nearBullFVGBot
obLongTrigger  = i_obEnabled and not na(bullOBEntry) and low <= nearBullOBTop and close > nearBullOBBot
oteLongTrigger = i_oteEnabled and inOTEZone and oteDirection == 1
liqLongTrigger = bullLiqSweep

longPDArray = fvgLongTrigger or obLongTrigger or oteLongTrigger or liqLongTrigger
longSignal  = canLong and structureBias == 1 and longPDArray and sessionOK and tradeAllowed and strategy.position_size == 0

// ── Composite Short Signal ──
fvgShortTrigger = i_fvgEnabled and not na(bearFVGEntry) and high >= nearBearFVGBot and close < nearBearFVGTop
obShortTrigger  = i_obEnabled and not na(bearOBEntry) and high >= nearBearOBBot and close < nearBearOBTop
oteShortTrigger = i_oteEnabled and inOTEZone and oteDirection == -1
liqShortTrigger = bearLiqSweep

shortPDArray = fvgShortTrigger or obShortTrigger or oteShortTrigger or liqShortTrigger
shortSignal  = canShort and structureBias == -1 and shortPDArray and sessionOK and tradeAllowed and strategy.position_size == 0

// ══════════════════════════════════════════════════════════════════════════════
// ─── STOP LOSS CALCULATION ──────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

buffer = atr14 * i_slBuffer

f_calcSL(_dir) =>
    float sl = na
    if i_slType == "Candle Body"
        // SL just beyond the body of the entry candle
        if _dir == 1
            sl := math.min(open, close) - buffer
        else
            sl := math.max(open, close) + buffer
    
    else if i_slType == "FVG Invalidation"
        if _dir == 1 and not na(nearBullFVGBot)
            sl := nearBullFVGBot - buffer
        else if _dir == -1 and not na(nearBearFVGTop)
            sl := nearBearFVGTop + buffer
        // Fallback to candle body if no FVG
        if na(sl)
            sl := _dir == 1 ? math.min(open, close) - buffer : math.max(open, close) + buffer
    
    else if i_slType == "OB Invalidation"
        if _dir == 1 and not na(nearBullOBBot)
            sl := nearBullOBBot - buffer
        else if _dir == -1 and not na(nearBearOBTop)
            sl := nearBearOBTop + buffer
        if na(sl)
            sl := _dir == 1 ? low - buffer : high + buffer
    
    else // Swing Point
        if _dir == 1 and not na(lastSwingLow)
            sl := lastSwingLow - buffer
        else if _dir == -1 and not na(lastSwingHigh)
            sl := lastSwingHigh + buffer
        if na(sl)
            sl := _dir == 1 ? low - atr14 : high + atr14
    sl

longSL  = f_calcSL(1)
shortSL = f_calcSL(-1)

// ══════════════════════════════════════════════════════════════════════════════
// ─── TAKE PROFIT CALCULATION ────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

longRisk   = close - longSL
shortRisk  = shortSL - close

longTP1  = close + longRisk * i_tp1RR
longTP2  = close + longRisk * i_tp2RR
shortTP1 = close - shortRisk * i_tp1RR
shortTP2 = close - shortRisk * i_tp2RR

// ══════════════════════════════════════════════════════════════════════════════
// ─── POSITION SIZING ────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// Risk-based position sizing
equityRisk = strategy.equity * (i_riskPct / 100)

f_posSize(_risk) =>
    _risk > 0 ? math.floor(equityRisk / _risk) : 0

longQty  = f_posSize(longRisk * syminfo.pointvalue)
shortQty = f_posSize(shortRisk * syminfo.pointvalue)

// ══════════════════════════════════════════════════════════════════════════════
// ─── EXECUTE TRADES ─────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

var string entryModel = ""

if longSignal
    qty = math.max(longQty, 1)
    strategy.entry("Long", strategy.long, qty=qty)
    dailyTrades += 1
    oteActive := false
    entryModel := liqLongTrigger ? "Liq Sweep" : oteLongTrigger ? "OTE" : obLongTrigger ? "OB" : "FVG"

if shortSignal
    qty = math.max(shortQty, 1)
    strategy.entry("Short", strategy.short, qty=qty)
    dailyTrades += 1
    oteActive := false
    entryModel := liqShortTrigger ? "Liq Sweep" : oteShortTrigger ? "OTE" : obShortTrigger ? "OB" : "FVG"

// ── TP1: Partial Close ──
if strategy.position_size > 0 and i_tp1Pct > 0
    strategy.exit("TP1 Long", "Long", qty_percent=i_tp1Pct, limit=longTP1, stop=longSL)
if strategy.position_size < 0 and i_tp1Pct > 0
    strategy.exit("TP1 Short", "Short", qty_percent=i_tp1Pct, limit=shortTP1, stop=shortSL)

// ── TP2: Second Partial ──
if strategy.position_size > 0 and i_tp2Pct > 0
    strategy.exit("TP2 Long", "Long", qty_percent=i_tp2Pct, limit=longTP2)
if strategy.position_size < 0 and i_tp2Pct > 0
    strategy.exit("TP2 Short", "Short", qty_percent=i_tp2Pct, limit=shortTP2)

// ── Trailing Stop for Remainder ──
if i_tpTrail and strategy.position_size != 0
    trailOffset = atr14 * i_trailATR
    if strategy.position_size > 0
        strategy.exit("Trail Long", "Long", trail_points=trailOffset / syminfo.mintick, trail_offset=trailOffset / syminfo.mintick)
    if strategy.position_size < 0
        strategy.exit("Trail Short", "Short", trail_points=trailOffset / syminfo.mintick, trail_offset=trailOffset / syminfo.mintick)

// ── Close Before Lunch ──
if i_closeLunch and isNYLunch and strategy.position_size != 0
    strategy.close_all("Lunch Close")

// ══════════════════════════════════════════════════════════════════════════════
// ─── VISUAL OVERLAYS ────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

// ── Killzone Background ──
kzColor = isLondonKZ ? color.new(#818cf8, 94) : isNYAMKZ ? color.new(#22d3ee, 94) : isNYPMKZ ? color.new(#f59e0b, 94) : isSilverAM ? color.new(#4ade80, 94) : isSilverPM ? color.new(#c084fc, 94) : na
bgcolor(i_kzFilter ? kzColor : na, title="Killzone BG")

// Lunch zone
bgcolor(isNYLunch ? color.new(#f87171, 96) : na, title="NY Lunch (Avoid)")

// ── Entry Signals on Chart ──
plotshape(longSignal, "Long Entry", shape.triangleup, location.belowbar, i_bullColor, size=size.small)
plotshape(shortSignal, "Short Entry", shape.triangledown, location.abovebar, i_bearColor, size=size.small)

// ── OTE Zone ──
p_oteTop = plot(oteActive and i_oteEnabled ? math.max(oteLevelLow, oteLevelHigh) : na, "OTE Top", color=color.new(#c084fc, 70), style=plot.style_linebr)
p_oteBot = plot(oteActive and i_oteEnabled ? math.min(oteLevelLow, oteLevelHigh) : na, "OTE Bottom", color=color.new(#c084fc, 70), style=plot.style_linebr)
fill(p_oteTop, p_oteBot, color=color.new(#c084fc, 92), title="OTE Zone Fill")
plot(oteActive and i_oteEnabled ? oteSweet : na, "OTE Sweet Spot", color=color.new(#c084fc, 50), style=plot.style_circles, linewidth=1)

// ── Structure Bias Bar Color ──
barcolor(structureBias == 1 ? color.new(i_bullColor, 70) : structureBias == -1 ? color.new(i_bearColor, 70) : na, title="Structure Bias Color")

// ══════════════════════════════════════════════════════════════════════════════
// ─── DASHBOARD ──────────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

if i_showDash and barstate.islast
    var table dash = table.new(position.top_right, 2, 12, bgcolor=color.new(#111113, 10), border_color=color.new(#27272a, 10), border_width=1, frame_color=color.new(#27272a, 10), frame_width=1)
    
    biasStr  = structureBias == 1 ? "BULLISH ▲" : structureBias == -1 ? "BEARISH ▼" : "NEUTRAL —"
    biasClr  = structureBias == 1 ? i_bullColor : structureBias == -1 ? i_bearColor : color.gray
    kzStr    = isLondonKZ ? "LONDON" : isNYAMKZ ? "NY AM" : isNYPMKZ ? "NY PM" : isSilverAM ? "SILVER AM" : isSilverPM ? "SILVER PM" : isNYLunch ? "LUNCH ⚠" : "OFF"
    kzClr    = isLondonKZ ? #818cf8 : isNYAMKZ ? #22d3ee : isNYPMKZ ? #f59e0b : isNYLunch ? #f87171 : color.gray
    
    activeFVGs = 0
    if array.size(fvgActiveArr) > 0
        for i = 0 to array.size(fvgActiveArr) - 1
            if array.get(fvgActiveArr, i)
                activeFVGs += 1
    
    activeOBs = 0
    if array.size(obActiveArr) > 0
        for i = 0 to array.size(obActiveArr) - 1
            if array.get(obActiveArr, i)
                activeOBs += 1
    
    dowStr = isMonday ? "MON" : dow == dayofweek.tuesday ? "TUE" : dow == dayofweek.wednesday ? "WED" : dow == dayofweek.thursday ? "THU" : isFriday ? "FRI" : "—"
    dowClr = isMonday ? #f87171 : dow == dayofweek.tuesday ? #4ade80 : dow == dayofweek.wednesday ? #4ade80 : dow == dayofweek.thursday ? #22d3ee : isFriday ? #f59e0b : color.gray
    
    table.cell(dash, 0, 0, "ICT PLAYBOOK", text_color=#22d3ee, text_size=size.small, text_halign=text.align_left)
    table.cell(dash, 1, 0, "v1.0", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 1, "Bias", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 1, biasStr, text_color=biasClr, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 2, "Killzone", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 2, kzStr, text_color=kzClr, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 3, "Day", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 3, dowStr, text_color=dowClr, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 4, "Active FVGs", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 4, str.tostring(activeFVGs), text_color=activeFVGs > 0 ? #4ade80 : color.gray, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 5, "Active OBs", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 5, str.tostring(activeOBs), text_color=activeOBs > 0 ? #22d3ee : color.gray, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 6, "OTE Zone", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 6, oteActive ? "ACTIVE" : "—", text_color=oteActive ? #c084fc : color.gray, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 7, "ATR(14)", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 7, str.tostring(atr14, "#.#####"), text_color=color.white, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 8, "Daily Trades", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 8, str.tostring(dailyTrades) + "/" + str.tostring(i_maxDailyTrades), text_color=dailyTrades >= i_maxDailyTrades ? #f87171 : #4ade80, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 9, "SL Type", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 9, i_slType, text_color=#f59e0b, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 10, "Entry Model", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    table.cell(dash, 1, 10, i_fvgEntry, text_color=#22d3ee, text_size=size.tiny, text_halign=text.align_right)
    
    table.cell(dash, 0, 11, "Position", text_color=color.gray, text_size=size.tiny, text_halign=text.align_left)
    posStr = strategy.position_size > 0 ? "LONG" : strategy.position_size < 0 ? "SHORT" : "FLAT"
    posClr = strategy.position_size > 0 ? i_bullColor : strategy.position_size < 0 ? i_bearColor : color.gray
    table.cell(dash, 1, 11, posStr, text_color=posClr, text_size=size.tiny, text_halign=text.align_right)

// ══════════════════════════════════════════════════════════════════════════════
// ─── ALERTS ─────────────────────────────────────────────────────────────────
// ══════════════════════════════════════════════════════════════════════════════

alertcondition(longSignal, "ICT Long Entry", "ICT Playbook — LONG entry signal. Bias: Bullish. Check FVG/OB/OTE confluence.")
alertcondition(shortSignal, "ICT Short Entry", "ICT Playbook — SHORT entry signal. Bias: Bearish. Check FVG/OB/OTE confluence.")
alertcondition(bullishMSS, "Bullish MSS", "Market Structure Shift — BULLISH. Displacement confirmed above swing high.")
alertcondition(bearishMSS, "Bearish MSS", "Market Structure Shift — BEARISH. Displacement confirmed below swing low.")
alertcondition(bullFVG, "Bullish FVG Formed", "New Bullish Fair Value Gap detected.")
alertcondition(bearFVG, "Bearish FVG Formed", "New Bearish Fair Value Gap detected.")
alertcondition(bullLiqSweep, "Bullish Liquidity Sweep", "Buy-side liquidity swept — watching for reversal long.")
alertcondition(bearLiqSweep, "Bearish Liquidity Sweep", "Sell-side liquidity swept — watching for reversal short.")
